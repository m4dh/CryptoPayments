# Crypto Payments - Architektura Systemu

## Diagram Architektury

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            FRONTEND (React)                                  │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐            │
│  │   Payment   │ │   Payment   │ │   Payment   │ │Subscription │            │
│  │   Plans     │ │   Form      │ │   Status    │ │   Status    │            │
│  └──────┬──────┘ └──────┬──────┘ └──────┬──────┘ └──────┬──────┘            │
│         │               │               │               │                    │
│         ▼               ▼               ▼               ▼                    │
│  ┌─────────────────────────────────────────────────────────────┐            │
│  │                    React Query + Hooks                       │            │
│  │  usePaymentPlans, usePayment, usePaymentStatus               │            │
│  └─────────────────────────────────────────────────────────────┘            │
└────────────────────────────────┬────────────────────────────────────────────┘
                                 │ REST API
                                 ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                            BACKEND (Express.js)                              │
│  ┌─────────────────────────────────────────────────────────────┐            │
│  │                      Controllers Layer                       │            │
│  │  paymentController.ts                                        │            │
│  │  - getPlans, initiate, confirm, getStatus, webhook          │            │
│  └──────────────────────────────┬──────────────────────────────┘            │
│                                 │                                            │
│  ┌──────────────────────────────▼──────────────────────────────┐            │
│  │                       Services Layer                         │            │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐            │            │
│  │  │  Payment    │ │  Blockchain │ │Subscription │            │            │
│  │  │  Service    │ │  Monitor    │ │  Service    │            │            │
│  │  │             │ │  Service    │ │             │            │            │
│  │  └──────┬──────┘ └──────┬──────┘ └──────┬──────┘            │            │
│  └─────────┼───────────────┼───────────────┼───────────────────┘            │
│            │               │               │                                 │
│  ┌─────────▼───────────────▼───────────────▼───────────────────┐            │
│  │                     Data Layer                               │            │
│  │  ┌───────────┐  ┌───────────┐  ┌───────────┐                │            │
│  │  │ PostgreSQL│  │ Blockchain│  │  Config   │                │            │
│  │  │ (payments,│  │ (RPCs for │  │  (env     │                │            │
│  │  │  subs)    │  │ monitoring│  │  vars)    │                │            │
│  │  └───────────┘  └───────────┘  └───────────┘                │            │
│  └─────────────────────────────────────────────────────────────┘            │
└─────────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         EXTERNAL SERVICES                                    │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                          │
│  │  Arbitrum   │  │    Tron     │  │  Ethereum   │                          │
│  │  RPC        │  │  TronGrid   │  │  RPC        │                          │
│  └─────────────┘  └─────────────┘  └─────────────┘                          │
└─────────────────────────────────────────────────────────────────────────────┘
```

## Komponenty Systemu

### 1. Frontend Layer

#### Technologie
- React 18 + TypeScript
- Vite (bundler)
- TailwindCSS + shadcn/ui (design system z CFDTrader)
- React Query v5 (cache, sync)
- Wouter (routing)
- i18next (PL/EN)
- QRCode.react (generowanie QR kodów)

#### Struktura Katalogów

```
client/src/features/payments/
├── components/
│   ├── PaymentPlans.tsx       # Lista dostępnych planów
│   ├── PaymentForm.tsx        # Formularz inicjacji płatności
│   ├── PaymentDetails.tsx     # Szczegóły płatności (adres, kwota, QR)
│   ├── PaymentStatus.tsx      # Status płatności z polling
│   ├── NetworkSelector.tsx    # Wybór sieci (Arbitrum/Tron/ETH)
│   ├── TokenSelector.tsx      # Wybór tokena (USDT/USDC)
│   └── AddressInput.tsx       # Input adresu nadawcy z walidacją
├── hooks/
│   ├── usePaymentPlans.ts     # Query dla planów
│   ├── usePayment.ts          # Mutacja inicjacji płatności
│   ├── usePaymentStatus.ts    # Query z polling statusu
│   └── usePaymentConfirm.ts   # Mutacja potwierdzenia
├── pages/
│   ├── PaymentPage.tsx        # Główna strona płatności
│   └── PaymentSuccessPage.tsx # Strona sukcesu
└── utils/
    ├── addressValidation.ts   # Walidacja adresów EVM/Tron
    └── networkConfig.ts       # Konfiguracja sieci
```

### 2. Backend Layer

#### Architektura: Controller → Service → Repository

```
server/
├── controllers/
│   └── paymentController.ts   # HTTP handlers
├── services/
│   ├── paymentService.ts      # Logika płatności
│   ├── blockchainMonitor.ts   # Monitoring transferów
│   ├── subscriptionService.ts # Zarządzanie subskrypcjami
│   └── paymentConfig.ts       # Konfiguracja sieci/tokenów
├── repositories/
│   ├── paymentRepository.ts   # CRUD payments
│   └── subscriptionRepository.ts # CRUD subscriptions
├── routes/
│   └── payments.ts            # Route definitions
├── jobs/
│   └── paymentMonitorJob.ts   # Scheduler dla monitoringu
└── utils/
    └── blockchainUtils.ts     # Helpers dla RPC
```

### 3. Data Layer

#### PostgreSQL Schema

```sql
-- Płatności
CREATE TABLE payments (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) NOT NULL,
  
  -- Plan
  plan_id VARCHAR(50) NOT NULL,
  
  -- Kwota
  amount DECIMAL(18, 6) NOT NULL,
  token VARCHAR(10) NOT NULL,           -- USDT, USDC
  network VARCHAR(20) NOT NULL,          -- arbitrum, tron, ethereum
  
  -- Adresy (szyfrowane)
  sender_address_encrypted TEXT NOT NULL,
  sender_address_hmac VARCHAR(64) NOT NULL,
  receiver_address VARCHAR(100) NOT NULL,
  
  -- Status
  status VARCHAR(30) NOT NULL DEFAULT 'pending',
  -- pending → awaiting_confirmation → confirmed | expired | failed
  
  -- Transakcja blockchain
  tx_hash VARCHAR(100),
  tx_confirmed_at TIMESTAMP,
  confirmations INTEGER DEFAULT 0,
  
  -- Timestamps
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  expires_at TIMESTAMP NOT NULL,         -- pending + 30 min
  
  -- Indeksy
  CONSTRAINT unique_pending_payment UNIQUE (user_id, status) 
    WHERE status IN ('pending', 'awaiting_confirmation')
);

-- Indeksy dla wyszukiwania
CREATE INDEX idx_payments_status ON payments(status);
CREATE INDEX idx_payments_sender_hmac ON payments(sender_address_hmac);
CREATE INDEX idx_payments_expires ON payments(expires_at) WHERE status = 'awaiting_confirmation';

-- Subskrypcje
CREATE TABLE subscriptions (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) UNIQUE NOT NULL,
  
  -- Plan
  plan_id VARCHAR(50) NOT NULL,
  
  -- Okres
  starts_at TIMESTAMP NOT NULL,
  ends_at TIMESTAMP,                     -- NULL = lifetime
  
  -- Powiązanie z płatnością
  payment_id INTEGER REFERENCES payments(id),
  
  -- Status
  status VARCHAR(20) NOT NULL DEFAULT 'active',
  -- active, expired, cancelled
  
  -- Timestamps
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_subscriptions_user ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_status ON subscriptions(status);
```

#### Drizzle Schema

```typescript
// shared/schema.ts

import { pgTable, serial, integer, varchar, text, timestamp, decimal, index, unique } from 'drizzle-orm/pg-core';

export const payments = pgTable('payments', {
  id: serial('id').primaryKey(),
  userId: integer('user_id').notNull().references(() => users.id),
  
  planId: varchar('plan_id', { length: 50 }).notNull(),
  
  amount: decimal('amount', { precision: 18, scale: 6 }).notNull(),
  token: varchar('token', { length: 10 }).notNull(),
  network: varchar('network', { length: 20 }).notNull(),
  
  senderAddressEncrypted: text('sender_address_encrypted').notNull(),
  senderAddressHmac: varchar('sender_address_hmac', { length: 64 }).notNull(),
  receiverAddress: varchar('receiver_address', { length: 100 }).notNull(),
  
  status: varchar('status', { length: 30 }).notNull().default('pending'),
  
  txHash: varchar('tx_hash', { length: 100 }),
  txConfirmedAt: timestamp('tx_confirmed_at'),
  confirmations: integer('confirmations').default(0),
  
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
  expiresAt: timestamp('expires_at').notNull(),
}, (table) => ({
  statusIdx: index('idx_payments_status').on(table.status),
  senderHmacIdx: index('idx_payments_sender_hmac').on(table.senderAddressHmac),
}));

export const subscriptions = pgTable('subscriptions', {
  id: serial('id').primaryKey(),
  userId: integer('user_id').notNull().references(() => users.id).unique(),
  
  planId: varchar('plan_id', { length: 50 }).notNull(),
  
  startsAt: timestamp('starts_at').notNull(),
  endsAt: timestamp('ends_at'),
  
  paymentId: integer('payment_id').references(() => payments.id),
  
  status: varchar('status', { length: 20 }).notNull().default('active'),
  
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
}, (table) => ({
  userIdx: index('idx_subscriptions_user').on(table.userId),
  statusIdx: index('idx_subscriptions_status').on(table.status),
}));
```

## Serwisy

### PaymentService

Główny serwis zarządzający płatnościami:

```typescript
// server/services/paymentService.ts

interface PaymentPlan {
  id: string;
  name: string;
  price: number;
  currency: 'USDC' | 'USDT';
  period: 'monthly' | 'yearly' | 'lifetime';
  features: string[];
}

interface InitiatePaymentParams {
  userId: number;
  planId: string;
  network: 'arbitrum' | 'tron' | 'ethereum';
  token: 'USDT' | 'USDC';
  senderAddress: string;
}

interface PaymentDetails {
  paymentId: number;
  receiverAddress: string;
  amount: string;
  token: string;
  network: string;
  expiresAt: Date;
  qrCodeData: string;
}

class PaymentService {
  constructor(
    private paymentRepository: PaymentRepository,
    private subscriptionService: SubscriptionService,
    private encryptionService: EncryptionService,
    private blockchainMonitor: BlockchainMonitorService
  ) {}

  async getPlans(): Promise<PaymentPlan[]> {
    return PAYMENT_PLANS;
  }

  async initiatePayment(params: InitiatePaymentParams): Promise<PaymentDetails> {
    // 1. Walidacja adresu
    this.validateAddress(params.senderAddress, params.network);
    
    // 2. Sprawdź czy użytkownik nie ma już pending payment
    const existing = await this.paymentRepository.findPendingByUser(params.userId);
    if (existing) {
      throw new PaymentError('Masz już oczekującą płatność', 'PENDING_EXISTS');
    }
    
    // 3. Pobierz cenę planu
    const plan = PAYMENT_PLANS.find(p => p.id === params.planId);
    if (!plan) {
      throw new PaymentError('Nieznany plan', 'INVALID_PLAN');
    }
    
    // 4. Pobierz adres odbiorcy
    const receiverAddress = this.getReceiverAddress(params.network);
    
    // 5. Szyfruj adres nadawcy
    const { encrypted, hmac } = await this.encryptionService.encryptWithHmac(
      params.senderAddress.toLowerCase()
    );
    
    // 6. Utwórz płatność
    const payment = await this.paymentRepository.create({
      userId: params.userId,
      planId: params.planId,
      amount: plan.price.toString(),
      token: params.token,
      network: params.network,
      senderAddressEncrypted: encrypted,
      senderAddressHmac: hmac,
      receiverAddress,
      status: 'pending',
      expiresAt: new Date(Date.now() + 30 * 60 * 1000), // 30 min
    });
    
    return {
      paymentId: payment.id,
      receiverAddress,
      amount: plan.price.toString(),
      token: params.token,
      network: params.network,
      expiresAt: payment.expiresAt,
      qrCodeData: this.generateQRData(receiverAddress, plan.price, params.token),
    };
  }

  async confirmPayment(paymentId: number, userId: number): Promise<void> {
    const payment = await this.paymentRepository.findById(paymentId);
    
    if (!payment || payment.userId !== userId) {
      throw new PaymentError('Płatność nie znaleziona', 'NOT_FOUND');
    }
    
    if (payment.status !== 'pending') {
      throw new PaymentError('Płatność nie jest w stanie pending', 'INVALID_STATUS');
    }
    
    // Zmień status i rozpocznij monitoring
    await this.paymentRepository.updateStatus(paymentId, 'awaiting_confirmation');
    
    // Dodaj do kolejki monitoringu
    this.blockchainMonitor.addToQueue(payment);
  }

  async handleConfirmedTransaction(
    paymentId: number,
    txHash: string,
    confirmations: number
  ): Promise<void> {
    // 1. Aktualizuj płatność
    await this.paymentRepository.update(paymentId, {
      status: 'confirmed',
      txHash,
      confirmations,
      txConfirmedAt: new Date(),
    });
    
    // 2. Aktywuj subskrypcję
    const payment = await this.paymentRepository.findById(paymentId);
    await this.subscriptionService.activate(payment.userId, payment.planId, paymentId);
    
    // 3. Wyślij powiadomienie (opcjonalne)
    // await this.notificationService.sendPaymentConfirmed(payment.userId);
  }

  private getReceiverAddress(network: string): string {
    if (network === 'tron') {
      return process.env.PAYMENT_ADDRESS_TRON!;
    }
    return process.env.PAYMENT_ADDRESS_EVM!;
  }

  private validateAddress(address: string, network: string): void {
    if (network === 'tron') {
      if (!address.startsWith('T') || address.length !== 34) {
        throw new PaymentError('Nieprawidłowy adres Tron', 'INVALID_ADDRESS');
      }
    } else {
      if (!address.match(/^0x[a-fA-F0-9]{40}$/)) {
        throw new PaymentError('Nieprawidłowy adres EVM', 'INVALID_ADDRESS');
      }
    }
  }

  private generateQRData(address: string, amount: number, token: string): string {
    // Format dla QR - prosty adres (użytkownik wpisuje kwotę ręcznie)
    return address;
  }
}
```

### BlockchainMonitorService

Serwis monitorujący blockchain w poszukiwaniu płatności:

```typescript
// server/services/blockchainMonitor.ts

interface MonitoredPayment {
  id: number;
  network: string;
  token: string;
  senderAddressHmac: string;
  receiverAddress: string;
  amount: string;
  expiresAt: Date;
}

class BlockchainMonitorService {
  private queue: MonitoredPayment[] = [];
  private isRunning = false;
  private readonly POLL_INTERVAL = 30000; // 30 sekund
  private readonly MIN_CONFIRMATIONS = {
    arbitrum: 3,
    ethereum: 3,
    tron: 19,
  };

  constructor(
    private evmService: EvmBlockchainService,
    private tronService: TronBlockchainService,
    private paymentRepository: PaymentRepository,
    private encryptionService: EncryptionService
  ) {}

  addToQueue(payment: MonitoredPayment): void {
    this.queue.push(payment);
    if (!this.isRunning) {
      this.startMonitoring();
    }
  }

  private async startMonitoring(): Promise<void> {
    this.isRunning = true;
    
    while (this.queue.length > 0) {
      // Usuń wygasłe płatności
      this.cleanExpired();
      
      // Sprawdź każdą płatność
      for (const payment of this.queue) {
        try {
          const result = await this.checkPayment(payment);
          
          if (result.found) {
            // Znaleziono transakcję!
            await this.handleFound(payment, result.txHash, result.confirmations);
            this.removeFromQueue(payment.id);
          }
        } catch (error) {
          console.error(`[PaymentMonitor] Error checking payment ${payment.id}:`, error);
        }
      }
      
      // Czekaj przed następnym sprawdzeniem
      await this.sleep(this.POLL_INTERVAL);
    }
    
    this.isRunning = false;
  }

  private async checkPayment(payment: MonitoredPayment): Promise<{
    found: boolean;
    txHash?: string;
    confirmations?: number;
  }> {
    if (payment.network === 'tron') {
      return this.tronService.findTransfer(payment);
    }
    return this.evmService.findTransfer(payment);
  }

  private async handleFound(
    payment: MonitoredPayment,
    txHash: string,
    confirmations: number
  ): Promise<void> {
    // Walidacja confirmations
    const minConfirmations = this.MIN_CONFIRMATIONS[payment.network];
    
    if (confirmations < minConfirmations) {
      // Czekaj na więcej potwierdzeń
      return;
    }
    
    // Przekaż do PaymentService
    await this.paymentService.handleConfirmedTransaction(
      payment.id,
      txHash,
      confirmations
    );
  }

  private cleanExpired(): void {
    const now = new Date();
    const expired = this.queue.filter(p => p.expiresAt < now);
    
    for (const payment of expired) {
      this.paymentRepository.updateStatus(payment.id, 'expired');
      this.removeFromQueue(payment.id);
    }
  }

  private removeFromQueue(paymentId: number): void {
    this.queue = this.queue.filter(p => p.id !== paymentId);
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

## Konfiguracja Sieci

```typescript
// server/config/paymentNetworks.ts

export const PAYMENT_NETWORKS = {
  arbitrum: {
    name: 'Arbitrum',
    chainId: 42161,
    rpcUrl: process.env.RPC_ARBITRUM || 'https://arb1.arbitrum.io/rpc',
    blockExplorer: 'https://arbiscan.io',
    nativeToken: 'ETH',
    minConfirmations: 3,
    tokens: {
      USDT: {
        address: '0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9',
        decimals: 6,
      },
      USDC: {
        address: '0xaf88d065e77c8cC2239327C5EDb3A432268e5831',
        decimals: 6,
      },
    },
  },
  tron: {
    name: 'Tron',
    rpcUrl: process.env.RPC_TRON || 'https://api.trongrid.io',
    blockExplorer: 'https://tronscan.org',
    nativeToken: 'TRX',
    minConfirmations: 19,
    tokens: {
      USDT: {
        address: 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t',
        decimals: 6,
      },
      USDC: {
        address: 'TEkxiTehnzSmSe2XqrBj4w32RUN966rdz8',
        decimals: 6,
      },
    },
  },
  ethereum: {
    name: 'Ethereum',
    chainId: 1,
    rpcUrl: process.env.RPC_ETHEREUM || 'https://eth.llamarpc.com',
    blockExplorer: 'https://etherscan.io',
    nativeToken: 'ETH',
    minConfirmations: 3,
    tokens: {
      USDT: {
        address: '0xdAC17F958D2ee523a2206206994597C13D831ec7',
        decimals: 6,
      },
      USDC: {
        address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
        decimals: 6,
      },
    },
  },
} as const;

export type PaymentNetwork = keyof typeof PAYMENT_NETWORKS;
export type PaymentToken = 'USDT' | 'USDC';
```

## Przepływ Danych

### 1. Inicjacja Płatności

```
User → POST /api/payments/initiate
  → paymentController.initiate()
    → paymentService.initiatePayment()
      → paymentRepository.create()
    ← PaymentDetails (address, amount, QR)
  ← JSON response
← UI displays payment details
```

### 2. Potwierdzenie i Monitoring

```
User clicks "Zapłaciłem" → POST /api/payments/:id/confirm
  → paymentController.confirm()
    → paymentService.confirmPayment()
      → paymentRepository.updateStatus('awaiting_confirmation')
      → blockchainMonitor.addToQueue(payment)
    ← Success
  ← JSON response

Background:
blockchainMonitor.startMonitoring()
  → evmService.findTransfer() / tronService.findTransfer()
    → Check ERC-20/TRC-20 Transfer events
  if found:
    → paymentService.handleConfirmedTransaction()
      → paymentRepository.update(confirmed)
      → subscriptionService.activate()
```

### 3. Sprawdzenie Statusu

```
UI polls GET /api/payments/:id/status
  → paymentController.getStatus()
    → paymentRepository.findById()
  ← { status, txHash, confirmations }

When status === 'confirmed':
  → Redirect to success page
  → Show subscription active
```
